import{_ as s,c as o,o as e,V as p}from"./chunks/framework.40a7f398.js";const m=JSON.parse('{"title":"🎢 Typescript 类型声明文件","description":"","frontmatter":{},"headers":[],"relativePath":"notes/ts 类型声明文件介绍.md","filePath":"notes/ts 类型声明文件介绍.md","lastUpdated":null}'),a={name:"notes/ts 类型声明文件介绍.md"},l=p(`<h1 id="🎢-typescript-类型声明文件" tabindex="-1">🎢 Typescript 类型声明文件 <a class="header-anchor" href="#🎢-typescript-类型声明文件" aria-label="Permalink to &quot;🎢 Typescript 类型声明文件&quot;">​</a></h1><blockquote><p>关于<code>typescript</code>一些类型声明文件的介绍，介绍如何正确使用类型声明文件，在<code>typescript</code>项目中获得类型安全的开发体验。 <code>typescript</code>类型声明文件是一种特殊的文件，用于描述 <code>javascript</code> 模块、库或代码中各种变量、函数和对象的<strong>类型信息</strong>。这对于在 <code>typescript</code> 项目中使用 <code>javascript</code> 库或模块以及在 <code>typescript</code> 中与 <code>javascript</code> 交互非常重要。</p></blockquote><h2 id="🌾-types-node-modules-types" tabindex="-1">🌾 @types(<code>node_modules/@types</code>) <a class="header-anchor" href="#🌾-types-node-modules-types" aria-label="Permalink to &quot;🌾 @types(\`node_modules/@types\`)&quot;">​</a></h2><blockquote><p><code>@types</code>是指 typescript 类型声明文件的命名空间。当在使用第三方库或框架时，可能需要相应的类型声明文件来帮助 typescript 进行类型检查和推导。</p><p><code>@types</code>命名空间是<strong>由 typescript 社区维护的一个公共存储库</strong>，它包含了许多常见第三方库的类型声明文件。这些类型声明文件具有与相应库的 API 和功能对应的类型定义，能够在 typescript 项目中获得类型安全的开发体验。</p></blockquote><h3 id="types-xxx" tabindex="-1"><code>@types/xxx</code> <a class="header-anchor" href="#types-xxx" aria-label="Permalink to &quot;\`@types/xxx\`&quot;">​</a></h3><p>在使用某个第三方库时，可以搜索该库的名称加上<code>@types</code>关键字，<em>以查找是否存在该库的类型声明文件</em>。例如，在使用<code>lodash</code>库，可以搜索<code>@types/lodash</code>来查找并安装与之对应的类型声明文件。</p><p>通过引入相应的类型声明文件，<code>typescript</code> 将能够识别使用的第三方库的类型，并提供相关的类型检查和代码补全功能，帮助避免一些潜在的类型错误。</p><blockquote><p>⚠️ <em>并不是所有的三方库都有相应的 <code>@types</code> 类型声明文件</em>。如果找不到某个库的类型声明文件，可能需要开发者<strong>手动为该库编写类型声明文件，或者查看社区是否已经有人为该库编写了类型声明文件。</strong></p></blockquote><h3 id="typescript如何识别使用的第三方库的类型" tabindex="-1"><code>typescript</code>如何识别使用的第三方库的类型 <a class="header-anchor" href="#typescript如何识别使用的第三方库的类型" aria-label="Permalink to &quot;\`typescript\`如何识别使用的第三方库的类型&quot;">​</a></h3><p>在添加相应的第三方库<strong>导入语句</strong>时，例如，如果要在代码中使用<code>lodash</code>，可以这样导入它： <code>import * as _ from &#39;lodash&#39;</code></p><p>现在，<strong>typescript 会自动识别对第三方库的导入(使用导入语句时)</strong>，并在代码中提供相应的类型检查和自动补全功能。这得益于引入了与该库对应的 <code>@types</code> 类型声明文件。</p><blockquote><p><strong>🪣 Details</strong></p><p>在上面的导入语句中注意到，在不使用 <code>typescript</code> 情况下 <code>import * as _ from &#39;lodash&#39;</code> or <code>import _ from &#39;lodash&#39;</code>都是没问题的，但是在使用 typescript 时，<code>import _ from &#39;lodash&#39;</code> 语句的导入确产生 typescript 错误警告，至于为什么在文章后续作出解释</p></blockquote><h2 id="🪼-typescript-如何自动识别第三方库类型" tabindex="-1">🪼 <code>typescript</code> 如何自动识别第三方库类型 <a class="header-anchor" href="#🪼-typescript-如何自动识别第三方库类型" aria-label="Permalink to &quot;🪼 \`typescript\` 如何自动识别第三方库类型&quot;">​</a></h2><p><b style="color:red;">在<code>typeScript</code>中，它能够自动识别第三方库的类型是因为**<code>typeScript</code>支持模块解析和类型推导的功能。**</b></p><ul><li><p>内置类型声明： <code>typescript</code> 内置了许多 <code>javascript</code> 标准库的类型声明，例如 Array、Promise、Object 等。这些内置类型声明可以直接在项目中使用，不需额外的安装或配置。</p></li><li><p>类型声明文件的命名约定(.d.ts)： <strong><code>typescript</code> 会根据命名约定查找类型声明文件</strong>。当引入一个第三方库时，typescript 会查找与该库同名的类型声明文件。例如，如果使用 axios 库，typescript 会尝试查找名为 axios.d.ts 的类型声明文件。</p><p>当在代码中使用<code>import</code>语句导入一个第三方库时，<code>typescript</code>会<em>尝试根据模块解析规则去查找相应的模块文件</em>。<strong>通常情况下，<code>typescript</code>会查找<em>与导入路径匹配的<code>.d.ts</code>类型声明文件</em>来获取类型信息。</strong><img src="https://cdn.jsdelivr.net/gh/iamsyygo/Store@master/image/202308212053112.png" alt=""></p></li><li><p>typescript 编译选项 &quot;typeRoots&quot; 和 &quot;types&quot;： 在 typescript 的配置文件（tsconfig.json）中，<strong>可以配置 typeRoots 和 types 选项来指定类型声明文件的搜索路径。typeRoots 允许指定额外的类型声明文件根目录，而 types 则是一个数组，包含了想引入的全局类型声明的模块名</strong>。typescript 将会在这些路径中搜索类型声明文件。 <img src="https://cdn.jsdelivr.net/gh/iamsyygo/Store@master/image/202308212100911.png" alt=""></p></li><li><p>类型声明文件合并：这指的是可以将多个类型声明文件合并为一个，从而在不破坏原始库的类型声明的情况下，为其添加额外的类型信息。</p></li><li><p>同时意味着，当安装了某个第三方库时，<code>typescript</code>会自动查找并识别与该库对应的<code>@types</code>类型声明文件（如果有的话），并使用它来提供类型检查和补全.</p></li><li><p>如果某个第三方库没有官方的<code>@types</code>类型声明文件，或者使用的是一个自定义的库，这时候可以手动编写类型声明文件(<code>.d.ts</code>)来为该库添加类型信息。</p><p>手动引入类型声明文件，可以按照以下步骤进行：</p><p>1、 遵循规范创建一个名为<code>&lt;library-name&gt;.d.ts</code>的文件</p><p>2、 <em><em>使用</em><code>declare module</code><em>语法来声明该库的类型</em></em></p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">module</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">library-name</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 在这里添加类型声明(包括接口、类、函数、常量等)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 模块内的类型声明</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">xxx</span><span style="color:#89DDFF;">():</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">void</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">interface</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">yyy</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 接口定义</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>3、 在<code>declare module</code>块中，可以编写适合该库的类型声明。<strong>这可能包括接口、类、函数、常量等</strong></p><p>4、 注意确保<code>tsconfig.json</code>的<strong>include 配置中是否包含该声明文件</strong></p><p>请注意，手动编写类型声明文件需要一定的类型推断和理解库的功能的能力。对于复杂的库或具有大量功能的库，编写类型声明可能会变得繁琐或困难。在这种情况下，可以查看社区是否已经有其他人为该库编写了类型声明文件。</p></li></ul><blockquote><p><strong>🪂 <code>typescript</code>在解析导入语句<code>import * as _ from &#39;lodash&#39;</code>时会检查以下几个位置</strong></p><ul><li>当前模块文件所在目录路径匹配下是否存在与导入路径匹配的<code>.ts</code>或<code>.tsx</code>文件，可以在包的 <code>package.json</code> 中配置 <code>types</code> 或 <code>typings</code> 字段来指定入口文件</li><li>如果第一步没有找到匹配的文件，则会检查当前文件所在目录下是否存在与导入路径匹配的<code>.d.ts</code>文件</li><li>如果前两步都没有找到匹配的文件，则会检查<code>node_modules/@types</code>目录下是否存在<strong>与导入库名称匹配的<code>.d.ts</code>文件</strong></li></ul></blockquote><h2 id="🛟-declare" tabindex="-1">🛟 <code>declare</code> <a class="header-anchor" href="#🛟-declare" aria-label="Permalink to &quot;🛟 \`declare\`&quot;">​</a></h2><blockquote><p><code>declare</code>是一个关键字，用于告诉编译器某个标识符（如变量、函数、命名空间等）的类型信息。它<b style="color:red;">用于声明全局变量、全局函数、命名空间等的类型，使得<code>typescript</code>能够正确地理解和推断这些标识符的类型。</b></p><p>ta 的作用是<strong>在编译时提供类型声明</strong>，而不会生成实际的<code>javascript</code>代码</p></blockquote><blockquote><p><b style="color:red;"><code>declare module</code> 是用于声明模块或库的类型声明的特定语法。</b>需要使用 <code>declare module</code> 语法来声明一个模块，以提供该模块的类型声明。使用 <code>declare module</code> 语法时，<strong>可以指定模块的名称，然后在模块的内部添加适合该模块的类型声明。</strong></p></blockquote><p><strong>使用 <code>declare</code> 关键字 or 不使用 <code>declare module</code></strong></p><p>当使用 <code>declare</code> 关键字而不使用 <code>declare module</code> 时，通常是<strong>在全局范围内声明全局变量、全局函数或全局命名空间的类型</strong>。这些类型声明告诉 <code>typescript</code>编译器有关全局标识符的类型信息，使得<code>typescript</code>能够正确地理解和推断它们的类型。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> gv</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span></span>
<span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">gf</span><span style="color:#89DDFF;">():</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span></span>
<span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">namespace</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">gnspace</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 命名空间内的类型声明</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="d-ts接口、函数、常量等-全局的类型声明" tabindex="-1"><code>.d.ts</code>接口、函数、常量等(<strong><em>全局的类型声明</em></strong>) <a class="header-anchor" href="#d-ts接口、函数、常量等-全局的类型声明" aria-label="Permalink to &quot;\`.d.ts\`接口、函数、常量等(**_全局的类型声明_**)&quot;">​</a></h3><blockquote><p><strong>🀄️ <code>declare module</code></strong></p><ul><li>通过在 <code>declare module</code> 中<em>定义接口</em>，可以描述模块或库的<strong>结构和功能</strong></li><li>在 <code>declare module</code> 中<em>声明函数</em>可以描述模块导出的<strong>函数的签名和参数类型</strong></li><li>通过在 <code>declare module</code> 中<em>声明常量</em>，可以描述模块<strong>导出的常量的类型和值</strong></li></ul></blockquote><p>上述中使用<code>declare module</code>是用于在<strong>特定的模块或库范围内提供类型声明</strong>。使用 <code>declare module</code> <strong>可以为模块或库提供更具体和封闭的类型定义</strong></p><p>而<code>declare</code>关键字用于提供类型声明，定义一个全局的类型声明如下：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span></span></code></pre></div><p>🍟 当需要全局定义一个 foo 变量类型，且<strong>它的类型为某个三方库的类型</strong>时：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 假设是在已经安装 pnpm add HelloWorld 第三方库并且拥有类型声明文件下，这个类型是从第三方库的类型声明文件中获取的</span></span>
<span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">HelloWorld</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// path: foo.d.ts</span></span></code></pre></div><p>然后就可以在整个项目中使用<code>foo</code>变量，并获得类型检查和补全的支持</p><blockquote><p>🛵 类型声明(<code>declare</code>)，不需要显式地导入。当使用 <code>declare</code> 关键字来声明一个变量时，它的类型会被视为全局可见，而不需要通过导入来获取该类型。</p><p>假设<code>HelloWorld</code>是在项目中安装的第三方类型声明文件**<code>@types/hello-world</code><strong>中定义的类型，</strong><code>typescript</code>编译器会自动识别该类型声明文件，并将其应用于整个项目，无需显式导入**。</p><p>因此，在全局范围内，无需显式导入<code>HelloWorld</code>，而是<em>通过正确安装和配置类型声明文件</em>，<strong><code>typescript</code>将自动找到并应用相应的类型</strong>。</p><p>总之，对于大多数情况下，当安装了第三方库和相应的类型声明文件时，<code>typescript</code>会自动识别和应用这些类型声明，而不需要手动导入(<code>path</code>这些 node 模块)</p></blockquote><blockquote><p><strong>🍓 然而，有些情况下，特别是在一些复杂的库或声明文件中，可能需要手动导入类型声明。这可能是因为类型声明文件的导出方式、模块化方式或者类型定义的特殊性造成的。</strong></p></blockquote><blockquote><p><strong>🤿 解释 <code>Why use as * in import</code></strong></p><ul><li><p>默认导出：如果第三方库的类型声明文件使用默认导（<code>export default</code>），需要使用<code>import</code>语句来导入并命名该默认导出的类型 --- <em>默认情况</em>，不需要使用<code>* as</code>语法</p></li><li><p>命名空间（Namespace）：<strong>如果第三方库的类型声明文件使用了命名空间</strong>，需要使用<code>import</code>语句来导入该命名空间下的类型，并且需要使用<code>* as xxx</code>方式来重命名该模块，例如 <code>import * as _ from &#39;lodash&#39;</code></p></li></ul><p><strong>这是因为命名空间下的类型是通过该命名空间访问的，而不是直接导出的。_使用 <code>import _ as</code>语法将整个命名空间导入为一个别名（例如<code>ModeXyy</code>）*，这样就可以使用该别名来访问命名空间下的类型。</strong></p><p>需要注意的是，<code>import * as</code> 语法只适用于命名空间的导入，而不适用于默认导出或其他导出形式。</p><ul><li><p>部分按需导入：有些类型声明文件可能仅导出部分类型，而不是全部。在这种情况下，需要使用<code>import</code>语句来导入需要的特定类型。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">yyy</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">xxx</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">library-name</span><span style="color:#89DDFF;">&#39;</span></span></code></pre></div></li><li><p>**全局变量或全局命名空间：如果第三方库在全局范围内声明了变量或命名空间，<em>并且没有提供对应的类型声明文件</em>，可能需要手动编写类型声明文件，<em>并在项目中引入该类型重新声明文件</em>。**这也是为什么需要在使用 element-plus 时需要导入重新声明类型文件。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// path: shims-xxx.d.ts</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">yyy</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">xxx</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">shims-xxx</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> X </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">shims-xxx</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">module</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">shims-xxx</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">yyy</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">yyy</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// Re-export the original types</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">X</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// or</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">namespace</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">additionalTypes</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">interface</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">xxx</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">interface</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">yyy</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></li></ul></blockquote><h2 id="🌋-reference-types-xxx-文件" tabindex="-1">🌋 /// &lt;reference types=&quot;xxx 文件&quot; /&gt; <a class="header-anchor" href="#🌋-reference-types-xxx-文件" aria-label="Permalink to &quot;🌋 /// \\&lt;reference types=&quot;xxx 文件&quot; /\\&gt;&quot;">​</a></h2><blockquote><p>在 Vite 工程中可以看到这样一个文件<code>vite-env.d.ts</code>，其中有这样一个内容<code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code></p><p>这是一种**<em>用于引用类型声明文件的特殊注释语法</em>，它通常用于在<code>typescript</code>中引入全局类型声明或扩展类型声明。**</p><p>使用 vite 也是，可以看到<code>vite/client</code>三方库中的类型文件声明了许多模块文件类型的类型声明</p><p>表示希望引入位于 <code>vite/client</code> 文件中的类型声明。这个注释<strong>告诉<code>typescript</code>编译器在编译过程中查找并使用该类型声明文件中定义的类型</strong>。这样可以<em>确保在编译过程中包含特定的文件，无论它们是否被直接导入到其他文件中</em></p></blockquote><p>⚠️ 需要注意的是，<code>/// &lt;reference</code> 注释的使用已经不再推荐，特别是在较新的<code>typescript</code>版本中。通常，使用模块导入语法（<code>import</code> 或 <code>export</code>）可以更好地管理文件的依赖关系和类型声明。</p>`,36),t=[l];function n(c,r,d,y,i,F){return e(),o("div",null,t)}const C=s(a,[["render",n]]);export{m as __pageData,C as default};
